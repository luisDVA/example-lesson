---
title: "Trabajando con datos rectangulares en el tidyverse: _tibbles_"
subtitle: "Clase de prueba para examen de certificaci√≥n de RStudio"
author: "Luis D. Verde Arregoitia"
institute: "https://liomys.mx"
output:
  xaringan::moon_reader:
    css: xaringan-themer.css
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r xaringan-themer, include=FALSE, warning=FALSE}
library(xaringanthemer)
style_mono_accent(
  base_color = "#1037A0",
    
  inverse_background_color = "#89c2d9",
  header_font_google = google_font("Josefin Sans"),
  text_font_google   = google_font("Montserrat", "300", "300i"),
  text_font_size = "1.8em",
  code_inline_color = "purple",
  code_font_google   = google_font("Fira Mono")
  )
```

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE,
        fig.align='center')
library("showtext")
```

```{r xaringan-tachyons, echo=FALSE, eval=TRUE}
xaringanExtra::use_tachyons()
```

```{r, echo=FALSE, eval=TRUE}
library(tibble)
library(datos)
```


</br >

## Datos rectangulares
.fl.w-30[
```{r, echo=FALSE, eval=TRUE, out.width="76%"}
knitr::include_graphics("rectangle1.png")
```
]


Cada fila tiene el mismo n√∫mero de columnas

Cada columna tiene el mismo n√∫mero de filas

Las columnas tienen la misma longitud (vectores y factores del mismo largo)

???

En nuestra disciplina dentro de la biolog√≠a, casi siempre trabajamos con datos rectangulares, sin importar el programa en el que los tengamos.

Rectangulares se refiere que que en una tabla con datos cada fila tiene el mismo n√∫mero de columnas y cada columna el mismo n√∫mero de filas. 

En este caso son tres columnas, todas del mismo largo, que conforman cinco filas.

Esto puede ser equivalente a un rango de celdas en una hoja de c√°lculo, donde necesariamente tenemos un rectangulo de datos, aunque dejemos algunas celdas en blanco.

---

# En R

`data.frame`    

La estructura fundamental para trabajar con datos rectangulares de dos dimensiones.

.pull-left[
```{r, eval=TRUE, echo=FALSE}
data.frame(
  x = c("a", "b", "c"),
  y = c(1, 2, 3)
)
```
]

<style>
.smaller {
  font-size: 70%
}
</style>

</br>
.smaller[
Lista de vectores del mismo largo
]

???
En R, el data frame es la estructura fundamental que usamos para guardar y trabajar con datos rectangulares. En resumen, es una lista de vectores del mismo largo, acomodados en dos dimensiones para formar filas y columnas.

---

<style>
.fakeh1{
  font-family: var(--header-font-family);
  font-size: 2.75rem;
  font-weight: 600;
  color: var(--header-color);
}
</style>

.center[.fakeh1[Tibbles] (/tibls/)]


Modernizando el `data.frame`  

Implementado para todo el `tidyverse` a trav√©s de üì¶ .b.orange[tibble]

.center[
```{r, eval=TRUE, echo=FALSE}
tibble(
  x = c("a", "b", "c"),
  y = c(1, 2, 3)
)
```
]



???

El objeto tibble hace lo mismo que el data frame. Almacena datos en dos dimensiones usando filas y columnas, pero tiene algunas diferencias fundamentales que lo hacen m√°s apto para los flujos de trabajo modernos.

Para darle un objeto com√∫n a los paquetes n√∫cleo del tidyverse, el paquete tibble implementa los objetos tibble, que facilitan una gram√°tica com√∫n y unifica los paquetes que m√°s usamos para manejar nuestros datos.

---

Las funciones m√°s utilizadas de .b.orange[dplyr], .b.orange[tidyr], y .b.orange[readr]
</br>

???
Es importante destacar que los tibbles no tienen porque romper nuestros flujos de trabajo. Las funciones de los paquetes que estaremos usando pueden trabajar con data frames, pero generalmente prefieren tibbles y por defecto estos son el tipo de objeto que crean, 
--

reciben un `data.frame` ‚û°Ô∏è regresan un `data.frame`  

--

reciben un `tibble` ‚û°Ô∏è regresan un `tibble`  

--

generan un objeto nuevo ‚û°Ô∏è crean un `tibble`

---

class: center, middle

# ¬øModernizando el `data.frame`?

???

Cuando digo que los tibble son una modernizaci√≥n del data frame, es porque el equipo que cre√≥ y mantiene los paquetes del tidyverse modific√≥ algunas de las conductas b√°sicas del data frame para crear un objeto que se presta menos a ambiguedades y que nos obliga, de buena manera, a escribir c√≥digo m√°s expresivo, es decir, c√≥digo que hace m√°s con menos, que transmite mejor lo que estamos haciendo, y que se puede interpretar m√°s f√°cilmente.  

---

```{r, echo=FALSE, eval=TRUE, out.width="85%", fig.align='center'}
knitr::include_graphics("motivational.png")
```

???

para ilustrar los principales cambios, les muestro esta imagen motivacional que es como algo que ver√≠amos en una oficina de gobierno. Esta imagen nos insta a hacer m√°s y quejarnos menos, pero los objetos tibble hacen lo contrario.

---

## tibbles

Hacen menos y se quejan m√°s (por nuestro bien)

***

???
Los tibbles hacen menos, y se quejan m√°s, mediante errores y advertencias.

--

.smaller[
- No asignan nombres a las filas 
]

???
A diferencia de los data frames, los tibbles no tienen un atributo adicional para almacenar r√≥tulos de cada una de las filas. Si queremos esa informaci√≥n, tiene que estar contenida expl√≠citamente en una columna. 

--

.smaller[
- No modifican los nombres de las columnas
]

???

Al crear o modificar data.frames, su comportamiento por defecto es de modificar los nombres de las columnas a un nombre v√°lido en R, esto incluye cambiar espacios o evitar nombres repetidos. cuando esto pasa en un data.frame no hay notificaci√≥n o advertencia, y esto nos puede tomar por sorpresa.


--

.fl.w-60.pv0[
.smaller[
- No convierten caracteres en factores  

- Exigen nombres completos para seleccionar subconjuntos de variables
]]

```{r, echo=FALSE, eval=TRUE, out.width="40%", fig.align='right'}
knitr::include_graphics("stringsfactors.png")
```

???

Esto √∫ltimo es m√°s t√©cnico, pero en la mayor√≠a de los casos no queremos que cambie el tipo de dato que hay en cada columna. Cuando tenemos texto en una columna, se queda como texto y no se transforma en una variable categ√≥rica con un n√∫mero fijo de niveles. Adem√°s, los tibbles son m√°s estrictos cuando queremos refererirnos a los nombres de las columnas, no permiten confusi√≥n o ambiguedad. 

---

class: inverse

<style>
.right-column{
  padding-top: 0;
}
</style>


## Creando `data.frames`

Podemos crear .b[data.frames] de tres maneras:


.pull-left[
Combinando vectores


Convirtiendo `tibbles`


Importando archivos]

.pull-right[.center.top[
.b.purple[`data.frame()`]</br></br> 

.b.purple[`as.data.frame()`]</br></br></br>  

.b.purple[`read.*()`]  
]]

---

class: inverse

<style>
.right-column{
  padding-top: 0;
}
</style>


## Creando `tibbles`

Podemos crear .b[tibbles] de tres maneras:


.pull-left[
Combinando vectores


Convirtiendo `data.frames`


Importando archivos con üì¶ .b[`readr`]
]

.pull-right[.center.top[
.b.purple[`tibble()`]</br></br> 

.b.purple[`as_tibble()`]</br></br></br>  

.b.purple[`read_\*()`]  
]]

---

# A crear data.frames üõ†Ô∏è

.smaller[
Con los vectores `x` & `y`
]

```{r}
  x <- c("a", "b", "c", "d")
  y <- c(1, -2, 3, NA)
```

.smaller[
Creamos un **data.frame** llamado 'prueba_df' y lo imprimimos en la consola
]


```{r}
prueba_df <- data.frame(x,y)
prueba_df
```

---

# A crear tibbles üõ†Ô∏è

.smaller[
Con los vectores `x` & `y`
]

```{r}
  x <- c("a", "b", "c", "d")
  y <- c(1, -2, 3, NA)
```

.smaller[
Creamos un **tibble** llamado 'prueba_tib' y lo imprimimos en la consola
]


```{r}
prueba_tib <- tibble(x,y)
prueba_tib
```

---

# M√°s quejas, menos acciones

.smaller[
Con el vector `x`
]
```{r}
x <- c(1, 3, 7, 9)
```

.smaller[
Ejecutemos el siguiente c√≥digo:
]
```{r, eval=FALSE}
data.frame(x,x)
tibble(x,x)
```

##.center[¬øQu√© pas√≥?]

---

</br>

üôã .smaller[Queremos convertir el `data.frame`  "_mtautos_" del paquete .b[datos] a `tibble` (√©ste ya se encuentra en nuestro entorno global y la documentaci√≥n nos dice que es un `data.frame`).</br></br>   ¬øCu√°l de est√°s funciones utilizamos?]

a) `tibble(mtautos)`  
b) `as_tibble(mtautos)`  
c) `c(mtautos)`  
d) `read_csv(mtautos)`

---
## Convirtiendo .orange[tibbles] y .orange[data.frames]
.smaller[Carga el paquete `datos`]
```{r, eval=FALSE}
library(datos)
```

.smaller[Convierte el objeto `mtautos` (es un `data.frame`) a `tibble` y gu√°rdalo como '_mtautos_tib_']

.smaller[Convierte el objeto '_mtautos_tib_' a `data.frame`]


---

# Imprimiendo tibbles

.smaller[
Por defecto, la impresi√≥n de `tibbles` en la consola nos muestra:
]

--

- Las primeras 10 filas 

--

- Cu√°ntas filas y columnas no se imprimieron

--

- Las columnas que entran en el ancho de nuestra pantalla

--

- El tipo de variable de todas las columnas


---

# Impresi√≥n en consola

Imprimamos el objeto bateadores del paquete `datos`

1) Como `data.frame`  
2) Como `tibble`

###.center[¬øCu√°l nos gusta m√°s?]

---

class: center, middle
## Tibbles
`
- Coexisten con, pero no reemplazan a los **data.frames**

--

- Sin sorpresas al crearlos o modificarlos

--

- Impresi√≥n en consola m√°s √∫til e informativa

---

# Lecturas relevantes

[Tibbles](https://r4ds-en-espaniol.netlify.app/tibbles.html)
, en R for Data Science en Espa√±ol

Comparando tibbles y data frames, del curso [Stat 545](https://stat545.com/basic-data-care.html#basic-data-care) de la Universidad de British Columbia (en ingl√©s)

La historia de [stringsAsFactors](https://simplystatistics.org/2015/07/24/stringsasfactors-an-unauthorized-biography/) (en ingl√©s)